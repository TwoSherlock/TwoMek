<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<p>&nbsp;&nbsp; 首先通俗的来说，三次握手相当于两个人在打电话：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第一次：</b>A打给B，A说：喂，能听到么？</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第二次：</b>B接到A的电话并听到了A的声音，回复：可以。你能听到我么？</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第三次：</b>A收到B的回复,"我也能听到"。此时可以确认二者之间成功建立了连接，开始进行交流。</p>
<br>
<p>TCP三次握手的具体过程如下：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第一次握手：</b>客户端发送SYN（SEQ=x）（同步序列编号Synchronize Sequence Numbers）报文给服务器端，进入等待状态，等待服务器确认。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第二次握手：</b>服务器端收到SYN报文，回应一个SYN （SEQ=y）+ACK(ACK=x+1 确认报文），进入等待状态，等待客户端确认。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第三次握手：</b>客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，服务器端和客户端进入连接状态。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;至此连接已经成功，可以开始传送数据了。</p>
<p>网上找了张图：</p>
<img src="${pageContext.request.contextPath }/img/tcp.jpg"/><br><br>
<p>&nbsp;&nbsp; 关闭TCP连接——改进的三次握手（四次挥手）</p>
<p><b>第一步：</b>主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</p>
<p><b>第二步：</b>主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</p>
<p><b>第三步：</b>主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</p>
<p><b>第四步：</b>主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</p>
<p>&nbsp;&nbsp; 虽然不是太恰当，但四次挥手的打电话过程模拟：</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第一次：</b>A→B，A：我请求挂电话。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第二次：</b>B接到A的请求，先做挂电话的准备工作，然后回复：我听到了。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第三次：</b>B的准备工作做完后，告诉A：我准备好了，现在可以挂电话。</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;<b>第三次：</b>A收到B的确认后，向B传达：那我挂了。挂掉电话。</p>
<p><b>为什么使用三次握手？两次不行么？</b></p>
<p>假设A发出的一个连接请求由于某种原因长时间滞留了，导致连接释放后的某个时间才到达B，本来这是一个失效的报文段，但是B认为这是A发出的申请，于是就向A发出确认，同意建立连接</p>
<p>如果采用的是两次握手，那么此时A、B之间就成功建立了连接。A此时不在等待状态，并不会理睬B的确认，也不会向B发送数据。但是B认为连接已经建立了，一直等待A发送数据，就这样浪费了许多资源。</p>
<p>采用三次握手就不会发生这种情况。A不理睬B，B没有收到A的确认请求，就不会建立连接。</p>
<br><br>
<p>既然提到了TCP，这里顺便提一下<b>TCP与UDP的区别</b></p>
<p><b>TCP:</b></p>
<p>·双向</p>
<p>·流模式</p>
<p>·要求系统资源较多</p>
<p>·保证数据正确性</p>
<p>·保证数据顺序</p>
<p><b>UDP:</b></p>
<p>·单向</p>
<p>·数据报模式</p>
<p>·要求系统资源较少</p>
<p>·可能丢包</p>
<p>·不保证数据顺序</p>









